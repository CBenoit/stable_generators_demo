use crate::generator::{Generator, YieldPoint};

// Data type our generator will yield back to the caller

pub enum Event<'a> {
    HttpRequest { url: &'a str },
    PayloadLen(usize),
}

// Data type our generator will accept back at interruption points

#[derive(Debug)]
pub enum UserResponse {
    Payload(Vec<u8>),
    SomeValue(u32),
}

// The actual code is written pretty much as usual, expect itâ€™s actually a state
// machine generated by the Rust compiler using async / await.
// This function is an implementation detail, not exposed to the user.

async fn do_something_impl<'a>(
    mut yield_point: YieldPoint<Event<'a>, UserResponse>,
    url: &'a str,
) -> u32 {
    let user_response = yield_point.suspend(Event::HttpRequest { url }).await;

    let UserResponse::Payload(payload) = user_response else {
        panic!("not payload")
    };

    let length = payload.len();

    let user_response = yield_point.suspend(Event::PayloadLen(length)).await;

    let UserResponse::SomeValue(some_value) = user_response else {
        panic!("not some value")
    };

    some_value
}

// The function actually exposed to the user, simply wrapping our underlying "async" state machine

pub fn do_something(url: &str) -> Generator<'_, Event, UserResponse, u32> {
    Generator::new(move |yield_point| async move { do_something_impl(yield_point, url).await })
}
